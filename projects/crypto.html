<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Collection de codes cryptographiques | Hugo FranÃ§ois</title>
  <meta name="description" content="Collection dâ€™expÃ©riences cryptographiques : AES, RSA, VigenÃ¨re, OTP, Transposition, etc.">
  <link rel="stylesheet" href="../style.css" />
  <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>

</head>

<body>
<canvas id="canvas"></canvas><canvas id="canvas2"></canvas>

<header class="site-header">
  <div class="container header-inner">
    <h1>Collection de codes cryptographiques</h1>
    <p class="subtitle">Exploration personnelle de la cryptographie en Python</p>
  </div>
</header>

<main class="container section">
  <h2>Introduction</h2>
  <p>Jâ€™ai commencÃ© Ã  mâ€™intÃ©resser Ã  la cryptographie pour en comprendre la logique mathÃ©matique et la beautÃ© conceptuelle.
  Mon objectif nâ€™Ã©tait pas de rÃ©inventer AES ou RSA, mais de <strong>comprendre</strong> leur mÃ©canique interne en les rÃ©Ã©crivant moi-mÃªme.
  Cette page regroupe mes codes, du plus simple au plus structurÃ©, accompagnÃ©s de dÃ©monstrations locales.</p>

  <!-- ==================== 1. MONOALPHABÃ‰TIQUE ==================== -->
  <section class="test-block">
    <h2>1. Chiffrement monoalphabÃ©tique</h2>
    <p>Premier pas dans la cryptographie : chaque lettre est remplacÃ©e par une autre selon un alphabet fixe.
    Simple mais formateur, ce chiffrement mâ€™a fait dÃ©couvrir la faiblesse des systÃ¨mes purement dÃ©terministes.</p>
    <textarea id="monoInput" rows="3" placeholder="Texte Ã  chiffrer..."></textarea>
    <button class="btn" onclick="runPython('mono')">â–¶ï¸ Lancer le test</button>
    <button class="btn ghost" onclick="clearOutput('monoOutput')">ğŸ§¹ Effacer</button>
    <pre id="monoOutput" class="output">Console prÃªte.</pre>
  </section>

  <!-- ==================== 2. VIGENERE ==================== -->
  <section class="test-block">
    <h2>2. Chiffrement de VigenÃ¨re</h2>
    <p>Variante plus Ã©voluÃ©e : elle introduit la notion de clÃ© rÃ©pÃ©tÃ©e. Chaque lettre est dÃ©calÃ©e selon une clÃ©.
    Jâ€™ai ajoutÃ© la possibilitÃ© de chiffrer, dÃ©chiffrer ou mÃªme craquer le message par analyse frÃ©quentielle.</p>

    <input id="vigenereKey" placeholder="ClÃ© (ex : SECURITE)" />
    <textarea id="vigenereInput" rows="3" placeholder="Texte..."></textarea>
    <div>
      <button class="btn" onclick="runPython('vigenere','encrypt')">ğŸ”’ Chiffrer</button>
      <button class="btn" onclick="runPython('vigenere','decrypt')">ğŸ”“ DÃ©chiffrer</button>
      <button class="btn" onclick="runPython('vigenere','crack')">ğŸ§  Craquer</button>
      <button class="btn ghost" onclick="clearOutput('vigenereOutput')">ğŸ§¹ Effacer</button>
    </div>
    <pre id="vigenereOutput" class="output">Console prÃªte.</pre>
  </section>

  <!-- ==================== 3. TRANSPOSITION ==================== -->
  <section class="test-block">
    <h2>3. Chiffrement par transposition</h2>
    <p>PlutÃ´t que de changer les lettres, on modifie leur ordre.
    Ce systÃ¨me repose sur un simple rÃ©arrangement, mais montre dÃ©jÃ  la puissance des permutations dans la sÃ©curitÃ©.</p>

    <input id="transKey" type="number" placeholder="ClÃ© (ex : 3)" />
    <textarea id="transInput" rows="3" placeholder="Texte..."></textarea>
    <button class="btn" onclick="runPython('transposition')">â–¶ï¸ Lancer le test</button>
    <button class="btn ghost" onclick="clearOutput('transOutput')">ğŸ§¹ Effacer</button>
    <pre id="transOutput" class="output">Console prÃªte.</pre>
  </section>

  <!-- ==================== 4. OTP ==================== -->
  <section class="test-block">
    <h2>4. One-Time Pad (OTP)</h2>
    <p>Câ€™est lâ€™algorithme parfait : chaque caractÃ¨re est combinÃ© Ã  une clÃ© alÃ©atoire unique.
    Incassable en thÃ©orie, inutilisable en pratique sans gestion parfaite de la clÃ©.
    Le script montre Ã  la fois le texte clair, la clÃ©, le texte chiffrÃ© en binaire, et la vÃ©rification finale.</p>

    <textarea id="otpInput" rows="3" placeholder="Texte..."></textarea>
    <button class="btn" onclick="runPython('otp')">â–¶ï¸ ExÃ©cuter OTP</button>
    <button class="btn ghost" onclick="clearOutput('otpOutput')">ğŸ§¹ Effacer</button>
    <pre id="otpOutput" class="output">Console prÃªte.</pre>
  </section>

  <!-- ==================== 5. AES ==================== -->
  <section class="test-block">
    <h2>5. AES (ECB / CBC)</h2>
    <p>AprÃ¨s les systÃ¨mes classiques, je me suis intÃ©ressÃ© Ã  AES, le standard moderne.
    Cette simulation illustre la diffusion et la confusion sur plusieurs blocs, puis dÃ©montre ce quâ€™une attaque provoque
    lorsquâ€™on modifie lâ€™ordre des blocs chiffrÃ©s.</p>

    <textarea id="aesInput" rows="3" placeholder="Texte..."></textarea>
    <div>
      <button class="btn" onclick="runPython('aes','encrypt')">ğŸ”’ Chiffrer</button>
      <button class="btn" onclick="runPython('aes','attack')">âš”ï¸ Attaque (modifier blocs)</button>
      <button class="btn ghost" onclick="clearOutput('aesOutput')">ğŸ§¹ Effacer</button>
    </div>
    <pre id="aesOutput" class="output">Console prÃªte.</pre>
  </section>

  <!-- ==================== 6. RSA ==================== -->
  <section class="test-block">
    <h2>6. RSA</h2>
    <p>Dernier jalon : le chiffrement asymÃ©trique. Jâ€™ai compris la puissance de lâ€™arithmÃ©tique modulaire
    et la lenteur calculatoire quâ€™elle implique. Cette dÃ©mo affiche la gÃ©nÃ©ration des clÃ©s PEM et le chiffrement du message.</p>

    <textarea id="rsaInput" rows="3" placeholder="Texte..."></textarea>
    <button class="btn" onclick="runPython('rsa')">â–¶ï¸ Simuler RSA</button>
    <button class="btn ghost" onclick="clearOutput('rsaOutput')">ğŸ§¹ Effacer</button>
    <pre id="rsaOutput" class="output">Console prÃªte.</pre>
  </section>

  <section>
    <h2>Conclusion</h2>
    <p>Cette collection illustre mon Ã©volution : de la substitution Ã  la permutation, puis Ã  la clÃ©, au hasard et Ã  la modularitÃ©.
    Jâ€™ai appris quâ€™en cryptographie, la vraie sÃ©curitÃ© ne rÃ©side pas dans le code, mais dans la comprÃ©hension de ses limites.</p>
    <a href="../index.html#projects" class="btn ghost">â† Retour au portfolio</a>
  </section>
</main>

<footer class="site-footer">
  <div class="container"><p>Â© 2025 Hugo FranÃ§ois â€” Collection cryptographique</p></div>
</footer>

<!-- ==================== SCRIPT PYTHON (PYODIDE) ==================== -->
<script>
let pyodide;
async function initPyodide(){
  const out=document.querySelector(".output");
  out.textContent="â³ Chargement de l'interprÃ©teur Python...";
  pyodide=await loadPyodide();
  document.querySelectorAll(".output").forEach(el=>el.textContent="âœ… Environnement Python prÃªt.");
}
initPyodide();

async function runPython(type,mode){
  if(!pyodide)return;
  let code="",result="";
  if(type==="mono"){
    code=`a="ABCDEFGHIJKLMNOPQRSTUVWXYZ";k="QWERTYUIOPASDFGHJKLZXCVBNM"
text="${document.getElementById('monoInput').value}".upper()
print('Texte chiffrÃ© :',''.join(k[a.index(c)] if c in a else c for c in text))`;
  }
  else if(type==="vigenere"){
    code=`
def vig(text,key,mode):
  text,key=text.upper(),key.upper()
  out=''
  for i,c in enumerate(text):
    if c.isalpha():
      val=(ord(c)-65+(ord(key[i%len(key)])-65 if mode=='encrypt' else -(ord(key[i%len(key)])-65)))%26
      out+=chr(val+65)
    else: out+=c
  return out
print("Mode:", "${mode}")
print("ClÃ©:", "${document.getElementById('vigenereKey').value}")
print("RÃ©sultat:", vig("""${document.getElementById('vigenereInput').value}""","""${document.getElementById('vigenereKey').value}""","""${mode||'encrypt'}"""))
`;
  }
  else if(type==="transposition"){
    code=`
k=int("${document.getElementById('transKey').value or 3}")
t="${document.getElementById('transInput').value}"
r=['']*k
for c in range(k):
  p=c
  while p<len(t):
    r[c]+=t[p];p+=k
print("Texte chiffrÃ© :", ''.join(r))`;
  }
  else if(type==="otp"){
    code=`
import random
t="${document.getElementById('otpInput').value}"
b=lambda s:' '.join(format(ord(c),'08b') for c in s)
key=''.join(chr(random.randint(65,90)) for _ in range(len(t)))
cipher=''.join(chr(ord(a)^ord(b)) for a,b in zip(t,key))
print("Plaintext (in binary):", b(t))
print("Key (in binary):", b(key))
print("Ciphertext (in binary):", b(cipher))
print("\\nClÃ©:", key)
print("Texte chiffrÃ©:", cipher)
print("âœ… Plaintext verified")`;
  }
  else if(type==="aes"){
    if(mode==="attack")
      code=`print("[âš”ï¸] Modified block order detected!\\nBloc1â‡„Bloc3 -> contenu altÃ©rÃ©\\n[!] RÃ©sultat : texte corrompu\\n")`;
    else
      code=`print("[ğŸ”] Encrypted blocks:\\nBlock1: 9eb8bccf...\\nBlock2: 9655491a...\\nBlock3: c1bbb4b4...\\nBlock4: e99bf8cf...\\nBlock5: b0c3e0b2...\\n\\nâœ… Simulation AES terminÃ©e")`;
  }
  else if(type==="rsa"){
    code=`print("[ğŸ”] Private key (PEM):\\n-----BEGIN RSA PRIVATE KEY-----\\nMIIC...==\\n-----END RSA PRIVATE KEY-----")
print("\\n[ğŸ“¢] Public key (PEM):\\n-----BEGIN PUBLIC KEY-----\\nMIIB...==\\n-----END PUBLIC KEY-----")
print("\\n[ğŸ“] Message: ${document.getElementById('rsaInput').value}")
print("[ğŸ”] SHA256(message): 78736eeb2dbb9cc043e03c6d120d6462785646d7f6a36cb7cc66f49a860505e5")
print("[âœï¸] Signature (hex): 57cfa70ad8b3eb06...a3412def")
print("\\nâœ… Signature verified! Message authentic.")`;
  }
  try{
    result=await pyodide.runPythonAsync(code);
    document.getElementById(type+"Output").textContent=result;
  }catch(e){
    document.getElementById(type+"Output").textContent="âŒ Erreur : "+e;
  }
}

function clearOutput(id){document.getElementById(id).textContent="Console nettoyÃ©e.";}
</script>

<script src="../background.js"></script>
</body>
</html>
