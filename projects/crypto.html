<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Collection de codes cryptographiques | Hugo Fran√ßois</title>
  <meta name="description" content="Collection d‚Äôexp√©riences cryptographiques : AES, RSA, Vigen√®re, OTP, Transposition et autres.">
  <link rel="stylesheet" href="../style.css" />
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
</head>
<body>
  <canvas id="canvas"></canvas>
  <canvas id="canvas2"></canvas>

  <header class="site-header">
    <div class="container header-inner">
      <h1>Collection de codes cryptographiques</h1>
      <p class="subtitle">Exp√©rimentations, impl√©mentations et visualisations en Python</p>
    </div>
  </header>

  <main class="container section">
    <h2>Introduction</h2>
    <p>
      Depuis mes premi√®res exp√©riences en s√©curit√©, j‚Äôai toujours aim√© comprendre comment les algorithmes de chiffrement fonctionnent ‚Äúde l‚Äôint√©rieur‚Äù.
      J‚Äôai donc pris le temps de r√©√©crire certains d‚Äôentre eux en Python, non pas pour la performance, mais pour apprendre leur logique, leur beaut√© math√©matique et leurs limites.
      Cette page regroupe mes principaux travaux, class√©s par ordre chronologique.
    </p>

    <!-- ==================== MONOALPHABETIC CIPHER ==================== -->
    <section>
      <h2>1. Chiffrement monoalphab√©tique</h2>
      <p>
        C‚Äôest le tout premier code que j‚Äôai √©crit en cryptographie. Il repose sur une substitution simple : chaque lettre claire est remplac√©e par une autre selon un alphabet fixe.
        Ce type de chiffrement, bien que fondamental historiquement, se casse facilement par analyse de fr√©quence. Mais il m‚Äôa permis de comprendre le lien entre structure et faiblesse d‚Äôun code.
      </p>

      <div class="test-zone">
        <h3>üß™ Zone de test</h3>
        <textarea id="monoInput" rows="3" placeholder="Texte √† chiffrer..."></textarea><br>
        <button onclick="runPython('mono')">Chiffrer</button>
        <pre id="monoOutput"></pre>
      </div>
    </section>

    <!-- ==================== VIGENERE ==================== -->
    <section>
      <h2>2. Chiffrement de Vigen√®re</h2>
      <p>
        Ce chiffrement repose sur une cl√© r√©p√©t√©e qui d√©cale les lettres selon une table modulaire. 
        Il est plus r√©sistant que le monoalphab√©tique, mais reste vuln√©rable √† une analyse statistique si la cl√© est courte.
        J‚Äôai aim√© le coder car il introduit la notion de cl√© et montre les limites du d√©terminisme dans le chiffrement.
      </p>

      <div class="test-zone">
        <h3>üß™ Zone de test</h3>
        <input id="vigenereKey" placeholder="Cl√©" /><br>
        <textarea id="vigenereInput" rows="3" placeholder="Texte √† chiffrer..."></textarea><br>
        <button onclick="runPython('vigenere')">Chiffrer</button>
        <pre id="vigenereOutput"></pre>
      </div>
    </section>

    <!-- ==================== TRANSPOSITION ==================== -->
    <section>
      <h2>3. Chiffrement par transposition</h2>
      <p>
        Cette fois, je ne change plus les lettres, mais leur position. 
        Le texte est √©crit dans une grille, puis relu selon un ordre d√©termin√© par une cl√© num√©rique.
        C‚Äôest un algorithme simple, mais tr√®s int√©ressant pour comprendre l‚Äôimportance de la permutation et de la structure.
      </p>

      <div class="test-zone">
        <h3>üß™ Zone de test</h3>
        <input id="transKey" type="number" placeholder="Cl√© (ex: 3)" /><br>
        <textarea id="transInput" rows="3" placeholder="Texte √† chiffrer..."></textarea><br>
        <button onclick="runPython('transposition')">Chiffrer</button>
        <pre id="transOutput"></pre>
      </div>
    </section>

    <!-- ==================== ONE TIME PAD ==================== -->
    <section>
      <h2>4. One-Time Pad (OTP)</h2>
      <p>
        Ce code repose sur une cl√© al√©atoire de la m√™me longueur que le message. 
        Chaque caract√®re est combin√© √† la cl√© via un XOR. 
        C‚Äôest le seul chiffrement th√©oriquement incassable, mais aussi le plus impraticable, car il n√©cessite une cl√© unique √† chaque √©change.
      </p>

      <div class="test-zone">
        <h3>üß™ Zone de test</h3>
        <textarea id="otpInput" rows="3" placeholder="Texte √† chiffrer..."></textarea><br>
        <button onclick="runPython('otp')">G√©n√©rer cl√© + chiffrer</button>
        <pre id="otpOutput"></pre>
      </div>
    </section>

    <!-- ==================== AES ==================== -->
    <section>
      <h2>5. AES (ECB / CBC)</h2>
      <p>
        Apr√®s avoir explor√© les anciens algorithmes, je me suis attaqu√© √† AES, le standard moderne.
        J‚Äôai reproduit une version logicielle simplifi√©e du chiffrement par blocs, d‚Äôabord en mode ECB puis en CBC.
        Le but n‚Äô√©tait pas la performance, mais la compr√©hension : SubBytes, ShiftRows et MixColumns deviennent beaucoup plus clairs lorsqu‚Äôon les code soi-m√™me.
      </p>

      <div class="test-zone">
        <h3>üß™ Zone de test</h3>
        <textarea id="aesInput" rows="3" placeholder="Texte √† chiffrer (AES simplifi√©)..."></textarea><br>
        <button onclick="runPython('aes')">Simuler AES</button>
        <pre id="aesOutput"></pre>
      </div>
    </section>

    <!-- ==================== RSA ==================== -->
    <section>
      <h2>6. RSA</h2>
      <p>
        Le dernier projet de cette collection a √©t√© RSA. 
        J‚Äôai impl√©ment√© la g√©n√©ration de cl√©s, le chiffrement et le d√©chiffrement √† l‚Äôaide d‚Äôexponentiation modulaire. 
        C‚Äôest un algorithme fascinant car il allie math√©matiques et s√©curit√© de mani√®re √©l√©gante.
        En le codant, j‚Äôai mieux compris les notions de nombres premiers, de modulo et de complexit√© calculatoire.
      </p>

      <div class="test-zone">
        <h3>üß™ Zone de test</h3>
        <textarea id="rsaInput" rows="3" placeholder="Texte √† chiffrer (RSA simul√©)..."></textarea><br>
        <button onclick="runPython('rsa')">Simuler RSA</button>
        <pre id="rsaOutput"></pre>
      </div>
    </section>

    <!-- ==================== CONCLUSION ==================== -->
    <section>
      <h2>Conclusion</h2>
      <p>
        Ce parcours m‚Äôa permis de d√©couvrir les fondements de la cryptographie moderne. 
        J‚Äôai commenc√© par manipuler des substitutions simples, puis j‚Äôai √©volu√© vers des syst√®mes bas√©s sur les blocs et les nombres premiers.
        Chacun de ces codes repr√©sente une √©tape dans ma compr√©hension : de la logique symbolique √† la complexit√© algorithmique.
        J‚Äôai compris que la s√©curit√© n‚Äôest pas qu‚Äôune question de chiffrement fort, mais de compr√©hension fine des limites de chaque mod√®le.
      </p>
      <a href="../index.html#projects" class="btn ghost">‚Üê Retour au portfolio</a>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p>¬© 2025 Hugo Fran√ßois ‚Äî Collection cryptographique</p>
    </div>
  </footer>

  <script src="../background.js"></script>

  <!-- ==================== PYTHON EXECUTION ENGINE ==================== -->
  <script>
    async function initPyodideAndRun(){
      if(!window.pyodide){
        window.pyodide = await loadPyodide();
      }
      return window.pyodide;
    }

    async function runPython(type){
      const pyodide = await initPyodideAndRun();
      let code = "";
      if(type === "mono"){
        code = `
def mono_cipher(text):
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    key = "QWERTYUIOPASDFGHJKLZXCVBNM"
    text = text.upper()
    result = ""
    for c in text:
        if c in alphabet:
            result += key[alphabet.index(c)]
        else:
            result += c
    return result

mono_cipher("""${document.getElementById('monoInput').value}""")
`;
        document.getElementById("monoOutput").textContent = pyodide.runPython(code);
      }
      else if(type === "vigenere"){
        code = `
def vigenere_encrypt(text, key):
    text, key = text.upper(), key.upper()
    res = ""
    for i, c in enumerate(text):
        if c.isalpha():
            res += chr((ord(c) - 65 + ord(key[i % len(key)]) - 65) % 26 + 65)
        else:
            res += c
    return res
vigenere_encrypt("""${document.getElementById('vigenereInput').value}""", """${document.getElementById('vigenereKey').value}""")
`;
        document.getElementById("vigenereOutput").textContent = pyodide.runPython(code);
      }
      else if(type === "transposition"){
        code = `
def transpose(text, key):
    key = int(key)
    res = [''] * key
    for col in range(key):
        pointer = col
        while pointer < len(text):
            res[col] += text[pointer]
            pointer += key
    return ''.join(res)
transpose("""${document.getElementById('transInput').value}""", """${document.getElementById('transKey').value}""")
`;
        document.getElementById("transOutput").textContent = pyodide.runPython(code);
      }
      else if(type === "otp"){
        code = `
import random
def otp(text):
    key = ''.join(chr(random.randint(65, 90)) for _ in range(len(text)))
    enc = ''.join(chr(ord(t) ^ ord(k)) for t, k in zip(text, key))
    return "Cl√©: " + key + "\\nTexte chiffr√©: " + enc
otp("""${document.getElementById('otpInput').value}""")
`;
        document.getElementById("otpOutput").textContent = pyodide.runPython(code);
      }
      else if(type === "aes"){
        document.getElementById("aesOutput").textContent = "Simulation AES : bloc transform√© (d√©mo simplifi√©e)";
      }
      else if(type === "rsa"){
        document.getElementById("rsaOutput").textContent = "Simulation RSA : g√©n√©ration de cl√© et chiffrement (d√©mo)";
      }
    }
  </script>
</body>
</html>
