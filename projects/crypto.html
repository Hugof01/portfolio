<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Collection de codes cryptographiques | Hugo Fran√ßois</title>
  <meta name="description" content="Collection d‚Äôexp√©riences cryptographiques : AES, RSA, Vigen√®re, OTP, Transposition, etc.">
  <link rel="stylesheet" href="../style.css" />
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
  <link rel="icon" type="image/png" href="assets/favicon.png">

  <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>

  <style>
    #output, .output {
      background: #111;
      color: #00ffbf;
      border-radius: 8px;
      padding: 12px;
      font-family: monospace;
      font-size: 14px;
      min-height: 150px;
      white-space: pre-wrap;
      box-shadow: 0 0 12px rgba(102,252,241,0.1);
      margin-top: 1em;
    }

    .test-block {
      background: rgba(255,255,255,0.02);
      padding: 1.5em;
      border-radius: 10px;
      margin: 2em 0;
      box-shadow: 0 0 20px rgba(102,252,241,0.08);
    }

    .test-block button {
      margin: 0.3em;
    }

    textarea, input {
      width: 100%;
      background: #0b0c10;
      color: #e6eef0;
      border: 1px solid rgba(102,252,241,0.2);
      border-radius: 8px;
      padding: 8px;
      margin: 0.5em 0;
      font-family: monospace;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>
  <canvas id="canvas2"></canvas>

  <header class="site-header">
    <div class="container header-inner">
      <h1>Collection de codes cryptographiques</h1>
      <p class="subtitle">Exploration personnelle de la cryptographie en Python</p>
    </div>
  </header>

  <main class="container section">
    <h2>Introduction</h2>
    <p>
      J‚Äôai commenc√© √† m‚Äôint√©resser √† la cryptographie pour en comprendre la logique math√©matique et la beaut√© conceptuelle.
      Mon objectif n‚Äô√©tait pas de r√©inventer AES ou RSA, mais de <strong>comprendre</strong> leur m√©canique interne en les r√©√©crivant moi-m√™me.
      Cette page regroupe mes codes, du plus simple au plus structur√©, accompagn√©s de d√©monstrations locales.
    </p>

    <!-- ==================== MONOALPHABETIC ==================== -->
    <section class="test-block">
      <h2>1. Chiffrement monoalphab√©tique</h2>
      <p>
        Premier pas dans la cryptographie : chaque lettre est remplac√©e par une autre selon un alphabet fixe.
        Simple mais formateur, ce chiffrement m‚Äôa fait d√©couvrir la faiblesse des syst√®mes purement d√©terministes.
      </p>

      <textarea id="monoInput" rows="3" placeholder="Texte √† chiffrer..."></textarea>
      <button class="btn" onclick="runPython('mono')">‚ñ∂Ô∏è Lancer le test</button>
      <button class="btn ghost" onclick="clearOutput('monoOutput')">üßπ Effacer</button>
      <pre id="monoOutput" class="output">Console pr√™te.</pre>
    </section>

    <!-- ==================== VIGENERE ==================== -->
    <section class="test-block">
      <h2>2. Chiffrement de Vigen√®re</h2>
      <p>
        Variante plus √©volu√©e, il introduit la notion de cl√© r√©p√©t√©e. 
        Chaque lettre est d√©cal√©e selon une cl√© : plus la cl√© est longue, plus le code r√©siste aux analyses.
      </p>

      <input id="vigenereKey" placeholder="Cl√© (ex : SECURITE)" />
      <textarea id="vigenereInput" rows="3" placeholder="Texte √† chiffrer..."></textarea>
      <button class="btn" onclick="runPython('vigenere')">‚ñ∂Ô∏è Lancer le test</button>
      <button class="btn ghost" onclick="clearOutput('vigenereOutput')">üßπ Effacer</button>
      <pre id="vigenereOutput" class="output">Console pr√™te.</pre>
    </section>

    <!-- ==================== TRANSPOSITION ==================== -->
    <section class="test-block">
      <h2>3. Chiffrement par transposition</h2>
      <p>
        Plut√¥t que de changer les lettres, on modifie leur ordre.
        Ce syst√®me repose sur un simple r√©arrangement, mais montre d√©j√† la puissance des permutations dans la s√©curit√©.
      </p>

      <input id="transKey" type="number" placeholder="Cl√© (ex : 3)" />
      <textarea id="transInput" rows="3" placeholder="Texte √† chiffrer..."></textarea>
      <button class="btn" onclick="runPython('transposition')">‚ñ∂Ô∏è Lancer le test</button>
      <button class="btn ghost" onclick="clearOutput('transOutput')">üßπ Effacer</button>
      <pre id="transOutput" class="output">Console pr√™te.</pre>
    </section>

    <!-- ==================== OTP ==================== -->
<section id="otp-demo" class="algo-block">
  <h2>4. One-Time Pad (OTP)</h2>
  <p>
    XOR caract√®re par caract√®re. Affichage binaire (8 bits) et ASCII.
  </p>

  <div class="controls" style="display:grid; gap:12px; max-width:900px;">
    <label>
      Message
      <textarea id="otp-msg" rows="3" placeholder="Entrez le message √† chiffrer"
                style="width:100%;"></textarea>
    </label>

    <div style="display:flex; gap:12px; align-items:flex-end; flex-wrap:wrap;">
      <label style="flex:1 1 320px;">
        Cl√©
        <input id="otp-key" type="text" placeholder="Entrez la cl√© (‚â• longueur du message)"
               style="width:100%;" />
      </label>

      <button id="otp-gen"
              title="G√©n√®re une cl√© al√©atoire de la bonne longueur">
        G√©n√©rer une cl√© al√©atoire
      </button>
    </div>

    <div style="display:flex; gap:12px; flex-wrap:wrap;">
      <button id="otp-run">Lancer le test</button>
      <button id="otp-clear" style="opacity:.8">Effacer</button>
      <small id="otp-hint" style="opacity:.8">
        Longueur message requise pour la cl√© : <span id="otp-need">0</span>
      </small>
    </div>
  </div>

  <div style="margin-top:16px;">
    <div class="output" id="otp-pt-bin"></div>
    <div class="output" id="otp-key-bin"></div>
    <div class="output" id="otp-ct-bin"></div>
    <div class="output" id="otp-ct-ascii"></div>
    <div class="output" id="otp-verify"></div>
  </div>
</section>

<script>
  // ===== Helpers =====
  const toBin8 = (n) => n.toString(2).padStart(8, "0");
  const strToBinLine = (s) =>
    Array.from(s, ch => toBin8(ch.charCodeAt(0))).join(" ");
  const xorStrings = (a, b) => {
    const n = a.length;
    let out = "";
    for (let i = 0; i < n; i++) {
      const c = a.charCodeAt(i) ^ b.charCodeAt(i);
      out += String.fromCharCode(c);
    }
    return out;
  };
  const randomKeyAZ = (len) => {
    const ABC = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let k = "";
    for (let i = 0; i < len; i++) k += ABC[Math.floor(Math.random()*ABC.length)];
    return k;
  };

  // ===== UI elements =====
  const $ = (id) => document.getElementById(id);
  const msgEl = $("otp-msg");
  const keyEl = $("otp-key");
  const needEl = $("otp-need");

  const outPtBin = $("otp-pt-bin");
  const outKeyBin = $("otp-key-bin");
  const outCtBin = $("otp-ct-bin");
  const outCtAscii = $("otp-ct-ascii");
  const outVerify = $("otp-verify");

  const setOutput = (el, title, body) => {
    el.textContent = title + "\n" + body;
  };
  const clearOutputs = () => {
    [outPtBin, outKeyBin, outCtBin, outCtAscii, outVerify].forEach(e => e.textContent = "");
  };

  // ===== Live hint for key length =====
  const updateNeed = () => { needEl.textContent = msgEl.value.length; };
  msgEl.addEventListener("input", updateNeed);
  updateNeed();

  // ===== Actions =====
  $("otp-gen").addEventListener("click", () => {
    const L = msgEl.value.length;
    keyEl.value = randomKeyAZ(L);
  });

  $("otp-clear").addEventListener("click", () => {
    msgEl.value = "";
    keyEl.value = "";
    clearOutputs();
    updateNeed();
  });

  $("otp-run").addEventListener("click", () => {
    clearOutputs();
    const msg = msgEl.value ?? "";
    const key = keyEl.value ?? "";

    if (!msg.length) {
      outVerify.textContent = "‚ö†Ô∏è Entrez un message.";
      return;
    }
    if (key.length < msg.length) {
      outVerify.textContent =
        `‚ùå Cl√© trop courte (cl√©=${key.length}, message=${msg.length}). ` +
        `La cl√© doit faire au moins ${msg.length} caract√®res.`;
      return;
    }

    // On tronque la cl√© au besoin pour un comportement strictement ‚ÄúOTP‚Äù
    const keyUse = key.slice(0, msg.length);

    // 1) Binaire plaintext & cl√©
    setOutput(outPtBin, "Plaintext (binaire 8 bits)", strToBinLine(msg));
    setOutput(outKeyBin, "Cl√© (binaire 8 bits)", strToBinLine(keyUse));

    // 2) Chiffrement (XOR caract√®re par caract√®re)
    const ct = xorStrings(msg, keyUse);

    // 3) Binaire + ASCII du ciphertext
    setOutput(outCtBin, "Ciphertext (binaire 8 bits)", strToBinLine(ct));
    setOutput(outCtAscii, "Ciphertext (ASCII)", ct);

    // 4) V√©rification (d√©crypt = XOR avec la m√™me cl√©)
    const recovered = xorStrings(ct, keyUse);
    const ok = recovered === msg;
    setOutput(
      outVerify,
      "V√©rification",
      ok ? `Plaintext v√©rifi√© ‚úÖ\n${recovered}` : "‚ùå √âchec de la v√©rification"
    );
  });
</script>

    <!-- ==================== AES ==================== -->
    <section class="test-block">
      <h2>5. AES (ECB / CBC)</h2>
      <p>
        Apr√®s les syst√®mes classiques, je me suis int√©ress√© √† AES, le standard moderne. 
        J‚Äôen ai cod√© une version simplifi√©e pour comprendre SubBytes, ShiftRows et MixColumns.
        L‚Äôobjectif √©tait d‚Äôobserver la diffusion et la confusion, pas de rivaliser avec une impl√©mentation r√©elle.
      </p>

      <textarea id="aesInput" rows="3" placeholder="Texte √† chiffrer (simulation)..."></textarea>
      <button class="btn" onclick="runPython('aes')">‚ñ∂Ô∏è Simuler AES</button>
      <button class="btn ghost" onclick="clearOutput('aesOutput')">üßπ Effacer</button>
      <pre id="aesOutput" class="output">Console pr√™te.</pre>
    </section>

    <!-- ==================== RSA ==================== -->
    <section class="test-block">
      <h2>6. RSA</h2>
      <p>
        Dernier jalon : le chiffrement asym√©trique. 
        En impl√©mentant RSA, j‚Äôai compris la puissance de l‚Äôarithm√©tique modulaire et la lenteur calculatoire qu‚Äôelle implique.
        Coder RSA m‚Äôa aussi fait r√©fl√©chir √† la fronti√®re entre √©l√©gance math√©matique et contraintes de performance.
      </p>

      <textarea id="rsaInput" rows="3" placeholder="Texte √† chiffrer (RSA simul√©)..."></textarea>
      <button class="btn" onclick="runPython('rsa')">‚ñ∂Ô∏è Simuler RSA</button>
      <button class="btn ghost" onclick="clearOutput('rsaOutput')">üßπ Effacer</button>
      <pre id="rsaOutput" class="output">Console pr√™te.</pre>
    </section>

    <!-- ==================== CONCLUSION ==================== -->
    <section>
      <h2>Conclusion</h2>
      <p>
        Cette collection illustre mon √©volution dans l‚Äôapprentissage de la cryptographie :
        passer d‚Äôune simple substitution √† la manipulation de blocs, de cl√©s, et de nombres premiers.
        Chaque script m‚Äôa permis de comprendre un concept diff√©rent :
        la substitution, la permutation, la cl√©, le hasard, la modularit√© et enfin la complexit√©.
        Ce travail m‚Äôa appris qu‚Äôen cryptographie, la vraie s√©curit√© ne r√©side pas dans le code, mais dans la compr√©hension de ses limites.
      </p>
      <a href="../index.html#projects" class="btn ghost">‚Üê Retour au portfolio</a>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container"><p>¬© 2025 Hugo Fran√ßois ‚Äî Collection cryptographique</p></div>
  </footer>

  <!-- ==================== SCRIPT PYTHON (PYODIDE) ==================== -->
  <script>
    let pyodide;
    async function initPyodide() {
      const firstOut = document.querySelector(".output");
      firstOut.textContent = "‚è≥ Chargement de l'interpr√©teur Python...";
      pyodide = await loadPyodide();
      document.querySelectorAll(".output").forEach(el => el.textContent = "‚úÖ Environnement Python pr√™t.");
    }
    initPyodide();

    async function runPython(type){
      if(!pyodide) return;
      let code = "";
      if(type === "mono"){
        code = `
def mono_cipher(t):
  a="ABCDEFGHIJKLMNOPQRSTUVWXYZ";k="QWERTYUIOPASDFGHJKLZXCVBNM"
  return ''.join(k[a.index(c)] if c in a else c for c in t.upper())
mono_cipher("""${document.getElementById('monoInput').value}""")
`;
        document.getElementById("monoOutput").textContent = await pyodide.runPythonAsync(code);
      }
      else if(type === "vigenere"){
        code = `
def vig(text,key):
  text,key=text.upper(),key.upper()
  r=""
  for i,c in enumerate(text):
    r+=chr((ord(c)-65+ord(key[i%len(key)])-65)%26+65) if c.isalpha() else c
  return r
vig("""${document.getElementById('vigenereInput').value}""","""${document.getElementById('vigenereKey').value}""")
`;
        document.getElementById("vigenereOutput").textContent = await pyodide.runPythonAsync(code);
      }
      else if(type === "transposition"){
        code = `
def transpose(t,k):
  k=int(k);r=['']*k
  for c in range(k):
    p=c
    while p<len(t):
      r[c]+=t[p];p+=k
  return ''.join(r)
transpose("""${document.getElementById('transInput').value}""","""${document.getElementById('transKey').value}""")
`;
        document.getElementById("transOutput").textContent = await pyodide.runPythonAsync(code);
      }
      else if(type === "aes"){
        document.getElementById("aesOutput").textContent = "Simulation AES : bloc trait√© (exemple conceptuel)";
      }
      else if(type === "rsa"){
        document.getElementById("rsaOutput").textContent = "Simulation RSA : g√©n√©ration de cl√©s et chiffrement symbolique";
      }
    }

    function clearOutput(id){
      document.getElementById(id).textContent = "Console nettoy√©e.";
    }
  </script>

  <script src="../background.js"></script>
</body>
</html>
