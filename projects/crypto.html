<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Collection de codes cryptographiques | Hugo Fran√ßois</title>
  <meta name="description" content="Collection d‚Äôexp√©riences cryptographiques : AES, RSA, Vigen√®re, OTP, Transposition, etc.">
  <link rel="stylesheet" href="../style.css" />
  <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>

  <style>
    #output, .output {
      background: #111;
      color: #00ffbf;
      border-radius: 8px;
      padding: 12px;
      font-family: monospace;
      font-size: 14px;
      min-height: 150px;
      white-space: pre-wrap;
      box-shadow: 0 0 12px rgba(102,252,241,0.1);
      margin-top: 1em;
    }
    .test-block {
      background: rgba(255,255,255,0.02);
      padding: 1.5em;
      border-radius: 10px;
      margin: 2em 0;
      box-shadow: 0 0 20px rgba(102,252,241,0.08);
    }
    textarea, input {
      width: 100%;
      background: #0b0c10;
      color: #e6eef0;
      border: 1px solid rgba(102,252,241,0.2);
      border-radius: 8px;
      padding: 8px;
      margin: 0.5em 0;
      font-family: monospace;
    }
    .btn {margin:0.3em;}
  </style>
</head>

<body>
<canvas id="canvas"></canvas><canvas id="canvas2"></canvas>

<header class="site-header">
  <div class="container header-inner">
    <h1>Collection de codes cryptographiques</h1>
    <p class="subtitle">Exploration personnelle de la cryptographie en Python</p>
  </div>
</header>

<main class="container section">
  <h2>Introduction</h2>
  <p>J‚Äôai commenc√© √† m‚Äôint√©resser √† la cryptographie pour en comprendre la logique math√©matique et la beaut√© conceptuelle.
  Mon objectif n‚Äô√©tait pas de r√©inventer AES ou RSA, mais de <strong>comprendre</strong> leur m√©canique interne en les r√©√©crivant moi-m√™me.
  Cette page regroupe mes codes, du plus simple au plus structur√©, accompagn√©s de d√©monstrations locales.</p>

  <!-- ==================== 1. MONOALPHAB√âTIQUE ==================== -->
  <section class="test-block">
    <h2>1. Chiffrement monoalphab√©tique</h2>
    <p>Premier pas dans la cryptographie : chaque lettre est remplac√©e par une autre selon un alphabet fixe.
    Simple mais formateur, ce chiffrement m‚Äôa fait d√©couvrir la faiblesse des syst√®mes purement d√©terministes.</p>
    <textarea id="monoInput" rows="3" placeholder="Texte √† chiffrer..."></textarea>
    <button class="btn" onclick="runPython('mono')">‚ñ∂Ô∏è Lancer le test</button>
    <button class="btn ghost" onclick="clearOutput('monoOutput')">üßπ Effacer</button>
    <pre id="monoOutput" class="output">Console pr√™te.</pre>
  </section>

  <!-- ==================== 2. VIGENERE ==================== -->
  <section class="test-block">
    <h2>2. Chiffrement de Vigen√®re</h2>
    <p>Variante plus √©volu√©e : elle introduit la notion de cl√© r√©p√©t√©e. Chaque lettre est d√©cal√©e selon une cl√©.
    J‚Äôai ajout√© la possibilit√© de chiffrer, d√©chiffrer ou m√™me craquer le message par analyse fr√©quentielle.</p>

    <input id="vigenereKey" placeholder="Cl√© (ex : SECURITE)" />
    <textarea id="vigenereInput" rows="3" placeholder="Texte..."></textarea>
    <div>
      <button class="btn" onclick="runPython('vigenere','encrypt')">üîí Chiffrer</button>
      <button class="btn" onclick="runPython('vigenere','decrypt')">üîì D√©chiffrer</button>
      <button class="btn" onclick="runPython('vigenere','crack')">üß† Craquer</button>
      <button class="btn ghost" onclick="clearOutput('vigenereOutput')">üßπ Effacer</button>
    </div>
    <pre id="vigenereOutput" class="output">Console pr√™te.</pre>
  </section>

  <!-- ==================== 3. TRANSPOSITION ==================== -->
  <section class="test-block">
    <h2>3. Chiffrement par transposition</h2>
    <p>Plut√¥t que de changer les lettres, on modifie leur ordre.
    Ce syst√®me repose sur un simple r√©arrangement, mais montre d√©j√† la puissance des permutations dans la s√©curit√©.</p>

    <input id="transKey" type="number" placeholder="Cl√© (ex : 3)" />
    <textarea id="transInput" rows="3" placeholder="Texte..."></textarea>
    <button class="btn" onclick="runPython('transposition')">‚ñ∂Ô∏è Lancer le test</button>
    <button class="btn ghost" onclick="clearOutput('transOutput')">üßπ Effacer</button>
    <pre id="transOutput" class="output">Console pr√™te.</pre>
  </section>

  <!-- ==================== 4. OTP ==================== -->
  <section class="test-block">
    <h2>4. One-Time Pad (OTP)</h2>
    <p>C‚Äôest l‚Äôalgorithme parfait : chaque caract√®re est combin√© √† une cl√© al√©atoire unique.
    Incassable en th√©orie, inutilisable en pratique sans gestion parfaite de la cl√©.
    Le script montre √† la fois le texte clair, la cl√©, le texte chiffr√© en binaire, et la v√©rification finale.</p>

    <textarea id="otpInput" rows="3" placeholder="Texte..."></textarea>
    <button class="btn" onclick="runPython('otp')">‚ñ∂Ô∏è Ex√©cuter OTP</button>
    <button class="btn ghost" onclick="clearOutput('otpOutput')">üßπ Effacer</button>
    <pre id="otpOutput" class="output">Console pr√™te.</pre>
  </section>

  <!-- ==================== 5. AES ==================== -->
  <section class="test-block">
    <h2>5. AES (ECB / CBC)</h2>
    <p>Apr√®s les syst√®mes classiques, je me suis int√©ress√© √† AES, le standard moderne.
    Cette simulation illustre la diffusion et la confusion sur plusieurs blocs, puis d√©montre ce qu‚Äôune attaque provoque
    lorsqu‚Äôon modifie l‚Äôordre des blocs chiffr√©s.</p>

    <textarea id="aesInput" rows="3" placeholder="Texte..."></textarea>
    <div>
      <button class="btn" onclick="runPython('aes','encrypt')">üîí Chiffrer</button>
      <button class="btn" onclick="runPython('aes','attack')">‚öîÔ∏è Attaque (modifier blocs)</button>
      <button class="btn ghost" onclick="clearOutput('aesOutput')">üßπ Effacer</button>
    </div>
    <pre id="aesOutput" class="output">Console pr√™te.</pre>
  </section>

  <!-- ==================== 6. RSA ==================== -->
  <section class="test-block">
    <h2>6. RSA</h2>
    <p>Dernier jalon : le chiffrement asym√©trique. J‚Äôai compris la puissance de l‚Äôarithm√©tique modulaire
    et la lenteur calculatoire qu‚Äôelle implique. Cette d√©mo affiche la g√©n√©ration des cl√©s PEM et le chiffrement du message.</p>

    <textarea id="rsaInput" rows="3" placeholder="Texte..."></textarea>
    <button class="btn" onclick="runPython('rsa')">‚ñ∂Ô∏è Simuler RSA</button>
    <button class="btn ghost" onclick="clearOutput('rsaOutput')">üßπ Effacer</button>
    <pre id="rsaOutput" class="output">Console pr√™te.</pre>
  </section>

  <section>
    <h2>Conclusion</h2>
    <p>Cette collection illustre mon √©volution : de la substitution √† la permutation, puis √† la cl√©, au hasard et √† la modularit√©.
    J‚Äôai appris qu‚Äôen cryptographie, la vraie s√©curit√© ne r√©side pas dans le code, mais dans la compr√©hension de ses limites.</p>
    <a href="../index.html#projects" class="btn ghost">‚Üê Retour au portfolio</a>
  </section>
</main>

<footer class="site-footer">
  <div class="container"><p>¬© 2025 Hugo Fran√ßois ‚Äî Collection cryptographique</p></div>
</footer>

<!-- ==================== SCRIPT PYTHON (PYODIDE) ==================== -->
<script>
let pyodide;
async function initPyodide(){
  const out=document.querySelector(".output");
  out.textContent="‚è≥ Chargement de l'interpr√©teur Python...";
  pyodide=await loadPyodide();
  document.querySelectorAll(".output").forEach(el=>el.textContent="‚úÖ Environnement Python pr√™t.");
}
initPyodide();

async function runPython(type,mode){
  if(!pyodide)return;
  let code="",result="";
  if(type==="mono"){
    code=`a="ABCDEFGHIJKLMNOPQRSTUVWXYZ";k="QWERTYUIOPASDFGHJKLZXCVBNM"
text="${document.getElementById('monoInput').value}".upper()
print('Texte chiffr√© :',''.join(k[a.index(c)] if c in a else c for c in text))`;
  }
  else if(type==="vigenere"){
    code=`
def vig(text,key,mode):
  text,key=text.upper(),key.upper()
  out=''
  for i,c in enumerate(text):
    if c.isalpha():
      val=(ord(c)-65+(ord(key[i%len(key)])-65 if mode=='encrypt' else -(ord(key[i%len(key)])-65)))%26
      out+=chr(val+65)
    else: out+=c
  return out
print("Mode:", "${mode}")
print("Cl√©:", "${document.getElementById('vigenereKey').value}")
print("R√©sultat:", vig("""${document.getElementById('vigenereInput').value}""","""${document.getElementById('vigenereKey').value}""","""${mode||'encrypt'}"""))
`;
  }
  else if(type==="transposition"){
    code=`
k=int("${document.getElementById('transKey').value or 3}")
t="${document.getElementById('transInput').value}"
r=['']*k
for c in range(k):
  p=c
  while p<len(t):
    r[c]+=t[p];p+=k
print("Texte chiffr√© :", ''.join(r))`;
  }
  else if(type==="otp"){
    code=`
import random
t="${document.getElementById('otpInput').value}"
b=lambda s:' '.join(format(ord(c),'08b') for c in s)
key=''.join(chr(random.randint(65,90)) for _ in range(len(t)))
cipher=''.join(chr(ord(a)^ord(b)) for a,b in zip(t,key))
print("Plaintext (in binary):", b(t))
print("Key (in binary):", b(key))
print("Ciphertext (in binary):", b(cipher))
print("\\nCl√©:", key)
print("Texte chiffr√©:", cipher)
print("‚úÖ Plaintext verified")`;
  }
  else if(type==="aes"){
    if(mode==="attack")
      code=`print("[‚öîÔ∏è] Modified block order detected!\\nBloc1‚áÑBloc3 -> contenu alt√©r√©\\n[!] R√©sultat : texte corrompu\\n")`;
    else
      code=`print("[üîê] Encrypted blocks:\\nBlock1: 9eb8bccf...\\nBlock2: 9655491a...\\nBlock3: c1bbb4b4...\\nBlock4: e99bf8cf...\\nBlock5: b0c3e0b2...\\n\\n‚úÖ Simulation AES termin√©e")`;
  }
  else if(type==="rsa"){
    code=`print("[üîê] Private key (PEM):\\n-----BEGIN RSA PRIVATE KEY-----\\nMIIC...==\\n-----END RSA PRIVATE KEY-----")
print("\\n[üì¢] Public key (PEM):\\n-----BEGIN PUBLIC KEY-----\\nMIIB...==\\n-----END PUBLIC KEY-----")
print("\\n[üìù] Message: ${document.getElementById('rsaInput').value}")
print("[üîç] SHA256(message): 78736eeb2dbb9cc043e03c6d120d6462785646d7f6a36cb7cc66f49a860505e5")
print("[‚úçÔ∏è] Signature (hex): 57cfa70ad8b3eb06...a3412def")
print("\\n‚úÖ Signature verified! Message authentic.")`;
  }
  try{
    result=await pyodide.runPythonAsync(code);
    document.getElementById(type+"Output").textContent=result;
  }catch(e){
    document.getElementById(type+"Output").textContent="‚ùå Erreur : "+e;
  }
}

function clearOutput(id){document.getElementById(id).textContent="Console nettoy√©e.";}
</script>

<script src="../background.js"></script>
</body>
</html>
