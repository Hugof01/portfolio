<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Moteurs polymorphiques & PRNG | Hugo FRANCOIS</title>
  <meta name="description" content="Recherche expérimentale sur les moteurs polymorphiques et générateurs pseudo-aléatoires.">
  <link rel="stylesheet" href="../style.css" />
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
  <link rel="icon" type="image/png" href="assets/favicon.png">

</head>
<body>
  <canvas id="canvas"></canvas>
  <canvas id="canvas2"></canvas>

  <header class="site-header">
    <div class="container header-inner">
      <h1>Moteurs polymorphiques & PRNG</h1>
      <p class="subtitle">Étude expérimentale d’un moteur polymorphique appliqué à la génération pseudo-aléatoire</p>
    </div>
  </header>

  <main class="container section">
    <h2>Introduction</h2>
    <p>
      Ce projet est né d’une idée assez simple : et si l’on pouvait représenter visuellement le comportement d’un moteur polymorphique,
      c’est-à-dire un système capable de changer continuellement sa forme tout en gardant une logique interne, et l’utiliser comme base
      d’un générateur pseudo-aléatoire ?  
      Mon objectif n’était pas de créer un générateur de nombres aléatoires classique, mais d’explorer une approche plus organique et géométrique
      du concept d’« entropie » en cryptographie.
    </p>

    <h2>1. Modélisation du moteur polymorphique</h2>
    <p>
      J’ai commencé par représenter ce moteur sous la forme d’un réseau polymorphique. Chaque sommet représente un point du système,
      et les arêtes traduisent les interactions entre ces points.  
      Le moteur se construit donc comme un graphe dynamique capable d’évoluer en fonction des paramètres d’entrée.
    </p>

    <figure class="project-media">
      <video controls width="70%">
        <source src="../assets/videos/video_moteur_poly.mp4" type="video/mp4">
        Votre navigateur ne supporte pas la lecture vidéo.
      </video>
      <figcaption>Visualisation du moteur polymorphique sous forme de réseau dynamique.</figcaption>
    </figure>

    <h2>2. Transformation en sphère déformable</h2>
    <p>
      Dans une seconde étape, j’ai voulu donner une forme plus cohérente et lisible au moteur : une <strong>sphère</strong>.
      Chaque sommet du graphe devient alors un point sur la surface, et l’ensemble forme une structure continue.  
      Cette sphère peut se déformer légèrement — certains points s’éloignent ou se rapprochent du centre — ce qui introduit une première forme
      d’aléa géométrique.  
      Ce comportement a des conséquences directes sur la génération du texte : selon la position des points,
      les lettres associées changent de manière subtile mais non répétitive.
    </p>

    <figure class="project-media">
      <video controls width="70%">
        <source src="../assets/videos/video_sphere_anim.mp4" type="video/mp4">
        Votre navigateur ne supporte pas la lecture vidéo.
      </video>
      <figcaption>La sphère se déforme : les sommets varient autour de leur position moyenne, introduisant une entropie spatiale.</figcaption>
    </figure>

    <h2>3. Ajout de la rotation</h2>
    <p>
      Pour augmenter la complexité du système, j’ai ajouté une <strong>rotation</strong> continue de la sphère sur elle-même.
      Cette nouvelle variable ajoute une source d’aléatoire temporelle : non seulement la sphère change de forme,
      mais elle évolue aussi dans le temps selon son axe de rotation.  
      Chaque sommet suit alors une trajectoire dans l’espace, et ces déplacements influencent directement les caractères générés.
    </p>

    <figure class="project-media">
      <video controls width="70%">
        <source src="../assets/videos/video_sphere_tournante.mp4" type="video/mp4">
        Votre navigateur ne supporte pas la lecture vidéo.
      </video>
      <figcaption>La sphère tourne sur elle-même, ajoutant une dimension temporelle à la génération aléatoire.</figcaption>
    </figure>

    <h2>4. Combinaison des deux formes d’aléatoire</h2>
    <p>
      Dans cette version, j’ai fusionné les deux phénomènes : la déformation et la rotation.
      La sphère devient alors véritablement polymorphe, car son état spatial évolue de manière non linéaire.
      Le moteur combine la position des sommets, leurs vitesses, leurs directions et leur distance au centre pour déterminer
      la prochaine valeur textuelle.
    </p>

    <figure class="project-media">
      <video controls width="70%">
        <source src="../assets/videos/video_sphere_anim_tournante.mp4" type="video/mp4">
        Votre navigateur ne supporte pas la lecture vidéo.
      </video>
      <figcaption>La combinaison des deux sources d’aléatoire renforce la complexité du moteur polymorphique.</figcaption>
    </figure>

    <h2>5. Application expérimentale — Génération de texte</h2>
    <p>
      La dernière vidéo montre l’application concrète de ce moteur : la génération d’un texte pseudo-aléatoire.
      Chaque lettre dépend de l’état instantané du moteur, c’est-à-dire de la position et de la déformation de la sphère.
      Le résultat n’est pas purement aléatoire, mais émergent : il découle d’une dynamique interne complexe.
    </p>

    <figure class="project-media">
      <video controls width="70%">
        <source src="../assets/videos/video_sphere_finale_texte.mp4" type="video/mp4">
        Votre navigateur ne supporte pas la lecture vidéo.
      </video>
      <figcaption>Le texte généré évolue selon les transformations du moteur polymorphique.</figcaption>
    </figure>

    <h2>Conclusion & perspectives</h2>
    <p>
      Ce projet m’a permis d’explorer une approche très visuelle et intuitive de la génération pseudo-aléatoire.
      Plutôt que de m’appuyer sur des formules statistiques classiques, j’ai cherché à modéliser le hasard
      comme une conséquence de l’instabilité d’un système géométrique en mouvement.
    </p>
    <p>
      De nombreuses questions restent ouvertes :  
      comment définir précisément le moment où un changement spatial implique un changement de caractère ?  
      Comment ajuster la vitesse de rotation ou d’élongation pour équilibrer la distribution des lettres ?  
      Peut-on adapter le moteur pour qu’il apprenne à générer des séquences « contrôlées » selon un objectif cryptographique précis ?
    </p>
    <p>
      À ce stade, je considère ce moteur comme une expérience plus artistique que mathématique.  
      Mais je crois que ce genre d’approches, à la frontière entre la géométrie, la physique et la cryptographie,
      peut ouvrir de nouvelles perspectives dans la compréhension du chaos calculatoire et des générateurs polymorphiques.
    </p>

    <div style="margin-top:30px;">
      <a href="../index.html#projects" class="btn ghost">← Retour au portfolio</a>
    </div>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p>© 2025 Hugo FRANCOIS — Moteurs polymorphiques & PRNG</p>
    </div>
  </footer>

  <script src="../background.js"></script>
</body>
</html>
